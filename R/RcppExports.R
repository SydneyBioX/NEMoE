# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Cpp function: Sample from a Dirichlet distribution
#' @param n Number of random vector to return.
#' @param a A positive vector of parameters.
#' @return A random matrix with n row from Dirichlet
#'  distribution with parameter a.
rDirichlet <- function(n, a) {
    .Call('_NEMoE_rDirichlet', PACKAGE = 'NEMoE', n, a)
}

#' Cpp function: Sample from Categorical distribution
#'
#' @param Prob A matrix with n row and p column. Each column represent a class.
#' The ith row is the probability distribution of ith sample.
#' @return A matrix of n row and p column. The ith row draw one
#' sample from categorical distribution with probability in the ith row in Prob.
rSample <- function(Prob) {
    .Call('_NEMoE_rSample', PACKAGE = 'NEMoE', Prob)
}

projMultiConstraint <- function(Beta0, alpha = 1) {
    .Call('_NEMoE_projMultiConstraint', PACKAGE = 'NEMoE', Beta0, alpha)
}

#' Cpp function: Calculate the estimated probability using softmax function
#' (multinomial regression).
#'
#' @param X a data matrix of input in multinomial regression.
#' @param B coefficients in multinomial regression.
#'
#' @return A matrix of multinomial probability with
#' p_i=exp(X %*% B_i)/sum(X %*% B)
#'
calcProb <- function(X, B) {
    .Call('_NEMoE_calcProb', PACKAGE = 'NEMoE', X, B)
}

#' Cpp function: Predict probability of mixture distribution
#' @param X a data matrix of input in experts network.
#' @param Z a data matrix of input in gating network.
#' @param y a vector of response.
#' @param W parameters in experts network.
#' @param V parameters in gating network.
#' @return A matrix of predicted probability with
#' predProb = pi * (1/(1 + exp(-X*W))),
#' pi = exp(Z * V_i)/sum(Z * V)
predProb <- function(X, Z, y, W, V) {
    .Call('_NEMoE_predProb', PACKAGE = 'NEMoE', X, Z, y, W, V)
}

#' Cpp function: Complete likelihood function of mixture distribution
#' @param X a data matrix of input in experts network.
#' @param Z a data matrix of input in gating network.
#' @param y a vector of response.
#' @param W parameters in experts network.
#' @param V parameters in gating network.
#' @return A matrix of complete likelihood by
#' compLikeli = pi * Likelihood = pi*(1/1+exp(-X*W))^y
#' pi = exp(Z * V_i)/sum(Z * V)
compLikeli <- function(X, Z, y, W, V) {
    .Call('_NEMoE_compLikeli', PACKAGE = 'NEMoE', X, Z, y, W, V)
}

#' Cpp function: calculate the four type of log likelihood function
#' (observed likelihood, penalized likelihood,
#' complete likelihood, penalized complete likelihood)
#' in all levels.
#' @param X an aggregated data matrix (n*P) of input in experts network
#' (rbind of all levels input).
#' @param Z a data matrix (n*q) of input in gating network.
#' @param y a vector of response (n).
#' @param seg an integer vector of length in each level (L).
#' @param W aggregated parameters in experts network (cbind of all levels)
#' ((P+L)*K).
#' @param V parameters in gating network((q+1)*K).
#' @param lambda1 aggregated penalty lambda parameters in experts network(P*K).
#' @param lambda2 penalty parameters lambda in gating network(q*1).
#' @param alpha1 penalty parameters alpha in experts network(L*K).
#' @param alpha2 penalty parameter alpha in gating network(1).
#' @param multiply a bool variable indicate whether lambda parameters
#'  times sample size.
#' @return A matrix of four types of likelihood function.
#'
calcLL <- function(X, Z, y, seg, W, V, lambda1, lambda2, alpha1, alpha2, multiply = FALSE) {
    .Call('_NEMoE_calcLL', PACKAGE = 'NEMoE', X, Z, y, seg, W, V, lambda1, lambda2, alpha1, alpha2, multiply)
}

#' Cpp function: fitting sparse multinomial regression.
#' @param X input matrix for sparse multinomial regression(n*p).
#' @param y response data for sparse multinomial regression(n*K).
#' @param lambda A vector of penalty parameters lambda (p*1).
#' @param alpha A number of penalty parameters alpha.
#' @param R A vector of weighted parameters for each sample(n*1).
#' @param beta_max A number of maximal number of fitted coefficients.
#' @return A matrix of fitted coefficients.
sMulti <- function(X, y, lambda, R, alpha, beta_max) {
    .Call('_NEMoE_sMulti', PACKAGE = 'NEMoE', X, y, lambda, R, alpha, beta_max)
}

#' Cpp function: fitting NEMoE paramters.
#' (observed likelihood, penalized likelihood,
#' complete likelihood, penalized complete likelihood)
#' in all levels.
#' @param X an aggregated data matrix (n*P) of input in experts network
#' (rbind of all levels input).
#' @param Z a data matrix (n*q) of input in gating network.
#' @param y a vector of response (n).
#' @param K A number of latent class.
#' @param seg an integer vector of length in each level (L).
#' @param W_init aggregated initial parameters in experts network
#' (cbind of all levels) ((P+L)*K).
#' @param V_init initial parameters in gating network((q+1)*K).
#' @param lambda1 aggregated penalty lambda parameters in experts network(P*K).
#' @param lambda2 penalty parameters lambda in gating network(q*1).
#' @param alpha1 penalty parameters alpha in experts network(L*K).
#' @param alpha2 penalty parameter alpha in gating network(1).
#' @param beta_max A number of maximal of coefficients to avoid divergence of
#' during the fitting.
#' @param EM_opt A integer indicate methods for EM algorithm.
#'  0="EM", 1 = "CEM", 2 = "SEM", 3= "SAEM", 4="GEM".
#' @param itmax maximal numbers of iteration in fitting NEMoE.
#' @param itmin minimal numbers of iteration in fitting NEMoE.
#' @param adapt A boolean variable indicates whether to use adaptive NEMoE.
#' @param btr A boolean variable indicates whether to use backtracking during
#' fitting NEMoE.
#' @param stop_all A boolean variable indicates whether to stop by
#' (likelihood converge)&(parameters converge)
#' @param verbose A boolean variable indicates whether to show PLL
#'  during each iteration.
#' @param early_stop A boolean variable indicates whether to stop when one
#' latent class have select zero variables (to save time).
#' @return A matrix of fitting result.
#'
fitNEMoE0 <- function(X, seg, Z, y, K, lambda1, lambda2, alpha1, alpha2, V_init, W_init, beta_max, EM_opt, itmax, itmin, adapt, btr, stop_all, verbose, early_stop = FALSE) {
    .Call('_NEMoE_fitNEMoE0', PACKAGE = 'NEMoE', X, seg, Z, y, K, lambda1, lambda2, alpha1, alpha2, V_init, W_init, beta_max, EM_opt, itmax, itmin, adapt, btr, stop_all, verbose, early_stop)
}

